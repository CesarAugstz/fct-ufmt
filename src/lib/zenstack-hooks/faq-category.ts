/******************************************************************************
 * This file was generated by ZenStack CLI.
 ******************************************************************************/

/* eslint-disable */
// @ts-nocheck

import type { Prisma, FaqCategory } from '@zenstackhq/runtime/models'
import type {
  UseMutationOptions,
  UseQueryOptions,
  UseInfiniteQueryOptions,
  InfiniteData,
} from '@tanstack/react-query'
import { getHooksContext } from '@zenstackhq/tanstack-query/runtime-v5/react'
import {
  useModelQuery,
  useInfiniteModelQuery,
  useModelMutation,
} from '@zenstackhq/tanstack-query/runtime-v5/react'
import type {
  PickEnumerable,
  CheckSelect,
  QueryError,
  ExtraQueryOptions,
  ExtraMutationOptions,
} from '@zenstackhq/tanstack-query/runtime-v5'
import type { PolicyCrudKind } from '@zenstackhq/runtime'
import metadata from './__model_meta'
type DefaultError = QueryError
import {
  useSuspenseModelQuery,
  useSuspenseInfiniteModelQuery,
} from '@zenstackhq/tanstack-query/runtime-v5/react'
import type {
  UseSuspenseQueryOptions,
  UseSuspenseInfiniteQueryOptions,
} from '@tanstack/react-query'

export function useCreateFaqCategory(
  options?: Omit<
    UseMutationOptions<
      FaqCategory | undefined,
      DefaultError,
      Prisma.FaqCategoryCreateArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryCreateArgs,
    DefaultError,
    FaqCategory,
    true
  >(
    'FaqCategory',
    'POST',
    `${endpoint}/faqCategory/create`,
    metadata,
    options,
    fetch,
    true,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryCreateArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryCreateArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
        | undefined
    },
  }
  return mutation
}

export function useCreateManyFaqCategory(
  options?: Omit<
    UseMutationOptions<
      Prisma.BatchPayload,
      DefaultError,
      Prisma.FaqCategoryCreateManyArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryCreateManyArgs,
    DefaultError,
    Prisma.BatchPayload,
    false
  >(
    'FaqCategory',
    'POST',
    `${endpoint}/faqCategory/createMany`,
    metadata,
    options,
    fetch,
    false,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryCreateManyArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryCreateManyArgs>,
      options?: Omit<
        UseMutationOptions<
          Prisma.BatchPayload,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryCreateManyArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(
        args,
        options as any,
      )) as Prisma.BatchPayload
    },
  }
  return mutation
}

export function useFindManyFaqCategory<
  TArgs extends Prisma.FaqCategoryFindManyArgs,
  TQueryFnData = Array<
    Prisma.FaqCategoryGetPayload<TArgs> & { $optimistic?: boolean }
  >,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindManyArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findMany`,
    args,
    options,
    fetch,
  )
}

export function useInfiniteFindManyFaqCategory<
  TArgs extends Prisma.FaqCategoryFindManyArgs,
  TQueryFnData = Array<Prisma.FaqCategoryGetPayload<TArgs>>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindManyArgs>,
  options?: Omit<
    UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>,
    'queryKey' | 'initialPageParam'
  >,
) {
  options = options ?? { getNextPageParam: () => null }
  const { endpoint, fetch } = getHooksContext()
  return useInfiniteModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findMany`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseFindManyFaqCategory<
  TArgs extends Prisma.FaqCategoryFindManyArgs,
  TQueryFnData = Array<
    Prisma.FaqCategoryGetPayload<TArgs> & { $optimistic?: boolean }
  >,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindManyArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    'queryKey'
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findMany`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseInfiniteFindManyFaqCategory<
  TArgs extends Prisma.FaqCategoryFindManyArgs,
  TQueryFnData = Array<Prisma.FaqCategoryGetPayload<TArgs>>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindManyArgs>,
  options?: Omit<
    UseSuspenseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>,
    'queryKey' | 'initialPageParam'
  >,
) {
  options = options ?? { getNextPageParam: () => null }
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseInfiniteModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findMany`,
    args,
    options,
    fetch,
  )
}

export function useFindUniqueFaqCategory<
  TArgs extends Prisma.FaqCategoryFindUniqueArgs,
  TQueryFnData = Prisma.FaqCategoryGetPayload<TArgs> & {
    $optimistic?: boolean
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindUniqueArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findUnique`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseFindUniqueFaqCategory<
  TArgs extends Prisma.FaqCategoryFindUniqueArgs,
  TQueryFnData = Prisma.FaqCategoryGetPayload<TArgs> & {
    $optimistic?: boolean
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindUniqueArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    'queryKey'
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findUnique`,
    args,
    options,
    fetch,
  )
}

export function useFindFirstFaqCategory<
  TArgs extends Prisma.FaqCategoryFindFirstArgs,
  TQueryFnData = Prisma.FaqCategoryGetPayload<TArgs> & {
    $optimistic?: boolean
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindFirstArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findFirst`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseFindFirstFaqCategory<
  TArgs extends Prisma.FaqCategoryFindFirstArgs,
  TQueryFnData = Prisma.FaqCategoryGetPayload<TArgs> & {
    $optimistic?: boolean
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryFindFirstArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    'queryKey'
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/findFirst`,
    args,
    options,
    fetch,
  )
}

export function useUpdateFaqCategory(
  options?: Omit<
    UseMutationOptions<
      FaqCategory | undefined,
      DefaultError,
      Prisma.FaqCategoryUpdateArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryUpdateArgs,
    DefaultError,
    FaqCategory,
    true
  >(
    'FaqCategory',
    'PUT',
    `${endpoint}/faqCategory/update`,
    metadata,
    options,
    fetch,
    true,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryUpdateArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryUpdateArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
        | undefined
    },
  }
  return mutation
}

export function useUpdateManyFaqCategory(
  options?: Omit<
    UseMutationOptions<
      Prisma.BatchPayload,
      DefaultError,
      Prisma.FaqCategoryUpdateManyArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryUpdateManyArgs,
    DefaultError,
    Prisma.BatchPayload,
    false
  >(
    'FaqCategory',
    'PUT',
    `${endpoint}/faqCategory/updateMany`,
    metadata,
    options,
    fetch,
    false,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryUpdateManyArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryUpdateManyArgs>,
      options?: Omit<
        UseMutationOptions<
          Prisma.BatchPayload,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryUpdateManyArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(
        args,
        options as any,
      )) as Prisma.BatchPayload
    },
  }
  return mutation
}

export function useUpsertFaqCategory(
  options?: Omit<
    UseMutationOptions<
      FaqCategory | undefined,
      DefaultError,
      Prisma.FaqCategoryUpsertArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryUpsertArgs,
    DefaultError,
    FaqCategory,
    true
  >(
    'FaqCategory',
    'POST',
    `${endpoint}/faqCategory/upsert`,
    metadata,
    options,
    fetch,
    true,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryUpsertArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryUpsertArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryUpsertArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
        | undefined
    },
  }
  return mutation
}

export function useDeleteFaqCategory(
  options?: Omit<
    UseMutationOptions<
      FaqCategory | undefined,
      DefaultError,
      Prisma.FaqCategoryDeleteArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryDeleteArgs,
    DefaultError,
    FaqCategory,
    true
  >(
    'FaqCategory',
    'DELETE',
    `${endpoint}/faqCategory/delete`,
    metadata,
    options,
    fetch,
    true,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryDeleteArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryDeleteArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, FaqCategory, Prisma.FaqCategoryGetPayload<T>>
        | undefined
    },
  }
  return mutation
}

export function useDeleteManyFaqCategory(
  options?: Omit<
    UseMutationOptions<
      Prisma.BatchPayload,
      DefaultError,
      Prisma.FaqCategoryDeleteManyArgs
    > &
      ExtraMutationOptions,
    'mutationFn'
  >,
) {
  const { endpoint, fetch } = getHooksContext()
  const _mutation = useModelMutation<
    Prisma.FaqCategoryDeleteManyArgs,
    DefaultError,
    Prisma.BatchPayload,
    false
  >(
    'FaqCategory',
    'DELETE',
    `${endpoint}/faqCategory/deleteMany`,
    metadata,
    options,
    fetch,
    false,
  )
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.FaqCategoryDeleteManyArgs>(
      args: Prisma.SelectSubset<T, Prisma.FaqCategoryDeleteManyArgs>,
      options?: Omit<
        UseMutationOptions<
          Prisma.BatchPayload,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.FaqCategoryDeleteManyArgs>
        > &
          ExtraMutationOptions,
        'mutationFn'
      >,
    ) => {
      return (await _mutation.mutateAsync(
        args,
        options as any,
      )) as Prisma.BatchPayload
    },
  }
  return mutation
}

export function useAggregateFaqCategory<
  TArgs extends Prisma.FaqCategoryAggregateArgs,
  TQueryFnData = Prisma.GetFaqCategoryAggregateType<TArgs>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryAggregateArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/aggregate`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseAggregateFaqCategory<
  TArgs extends Prisma.FaqCategoryAggregateArgs,
  TQueryFnData = Prisma.GetFaqCategoryAggregateType<TArgs>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryAggregateArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    'queryKey'
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/aggregate`,
    args,
    options,
    fetch,
  )
}

export function useGroupByFaqCategory<
  TArgs extends Prisma.FaqCategoryGroupByArgs,
  HasSelectOrTake extends Prisma.Or<
    Prisma.Extends<'skip', Prisma.Keys<TArgs>>,
    Prisma.Extends<'take', Prisma.Keys<TArgs>>
  >,
  OrderByArg extends Prisma.True extends HasSelectOrTake
    ? { orderBy: Prisma.FaqCategoryGroupByArgs['orderBy'] }
    : { orderBy?: Prisma.FaqCategoryGroupByArgs['orderBy'] },
  OrderFields extends Prisma.ExcludeUnderscoreKeys<
    Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs['orderBy']>>
  >,
  ByFields extends Prisma.MaybeTupleToUnion<TArgs['by']>,
  ByValid extends Prisma.Has<ByFields, OrderFields>,
  HavingFields extends Prisma.GetHavingFields<TArgs['having']>,
  HavingValid extends Prisma.Has<ByFields, HavingFields>,
  ByEmpty extends TArgs['by'] extends never[] ? Prisma.True : Prisma.False,
  InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
        }[HavingFields]
      : 'take' extends Prisma.Keys<TArgs>
        ? 'orderBy' extends Prisma.Keys<TArgs>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<TArgs>
          ? 'orderBy' extends Prisma.Keys<TArgs>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                }[OrderFields]
            : 'Error: If you provide "skip", you also need to provide "orderBy"'
          : ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields],
  TQueryFnData = {} extends InputErrors
    ? Array<
        PickEnumerable<Prisma.FaqCategoryGroupByOutputType, TArgs['by']> & {
          [P in keyof TArgs &
            keyof Prisma.FaqCategoryGroupByOutputType]: P extends '_count'
            ? TArgs[P] extends boolean
              ? number
              : Prisma.GetScalarType<
                  TArgs[P],
                  Prisma.FaqCategoryGroupByOutputType[P]
                >
            : Prisma.GetScalarType<
                TArgs[P],
                Prisma.FaqCategoryGroupByOutputType[P]
              >
        }
      >
    : InputErrors,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<
    TArgs,
    Prisma.SubsetIntersection<
      TArgs,
      Prisma.FaqCategoryGroupByArgs,
      OrderByArg
    > &
      InputErrors
  >,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/groupBy`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseGroupByFaqCategory<
  TArgs extends Prisma.FaqCategoryGroupByArgs,
  HasSelectOrTake extends Prisma.Or<
    Prisma.Extends<'skip', Prisma.Keys<TArgs>>,
    Prisma.Extends<'take', Prisma.Keys<TArgs>>
  >,
  OrderByArg extends Prisma.True extends HasSelectOrTake
    ? { orderBy: Prisma.FaqCategoryGroupByArgs['orderBy'] }
    : { orderBy?: Prisma.FaqCategoryGroupByArgs['orderBy'] },
  OrderFields extends Prisma.ExcludeUnderscoreKeys<
    Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs['orderBy']>>
  >,
  ByFields extends Prisma.MaybeTupleToUnion<TArgs['by']>,
  ByValid extends Prisma.Has<ByFields, OrderFields>,
  HavingFields extends Prisma.GetHavingFields<TArgs['having']>,
  HavingValid extends Prisma.Has<ByFields, HavingFields>,
  ByEmpty extends TArgs['by'] extends never[] ? Prisma.True : Prisma.False,
  InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
        }[HavingFields]
      : 'take' extends Prisma.Keys<TArgs>
        ? 'orderBy' extends Prisma.Keys<TArgs>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<TArgs>
          ? 'orderBy' extends Prisma.Keys<TArgs>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                }[OrderFields]
            : 'Error: If you provide "skip", you also need to provide "orderBy"'
          : ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields],
  TQueryFnData = {} extends InputErrors
    ? Array<
        PickEnumerable<Prisma.FaqCategoryGroupByOutputType, TArgs['by']> & {
          [P in keyof TArgs &
            keyof Prisma.FaqCategoryGroupByOutputType]: P extends '_count'
            ? TArgs[P] extends boolean
              ? number
              : Prisma.GetScalarType<
                  TArgs[P],
                  Prisma.FaqCategoryGroupByOutputType[P]
                >
            : Prisma.GetScalarType<
                TArgs[P],
                Prisma.FaqCategoryGroupByOutputType[P]
              >
        }
      >
    : InputErrors,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<
    TArgs,
    Prisma.SubsetIntersection<
      TArgs,
      Prisma.FaqCategoryGroupByArgs,
      OrderByArg
    > &
      InputErrors
  >,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    'queryKey'
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/groupBy`,
    args,
    options,
    fetch,
  )
}

export function useCountFaqCategory<
  TArgs extends Prisma.FaqCategoryCountArgs,
  TQueryFnData = TArgs extends { select: any }
    ? TArgs['select'] extends true
      ? number
      : Prisma.GetScalarType<
          TArgs['select'],
          Prisma.FaqCategoryCountAggregateOutputType
        >
    : number,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryCountArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/count`,
    args,
    options,
    fetch,
  )
}

export function useSuspenseCountFaqCategory<
  TArgs extends Prisma.FaqCategoryCountArgs,
  TQueryFnData = TArgs extends { select: any }
    ? TArgs['select'] extends true
      ? number
      : Prisma.GetScalarType<
          TArgs['select'],
          Prisma.FaqCategoryCountAggregateOutputType
        >
    : number,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.FaqCategoryCountArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    'queryKey'
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/count`,
    args,
    options,
    fetch,
  )
}

export function useCheckFaqCategory<TError = DefaultError>(
  args: {
    operation: PolicyCrudKind
    where?: {
      id?: string
      name?: string
      description?: string
      order?: number
      courseId?: string
    }
  },
  options?: Omit<UseQueryOptions<boolean, TError, boolean>, 'queryKey'> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext()
  return useModelQuery<boolean, boolean, TError>(
    'FaqCategory',
    `${endpoint}/faqCategory/check`,
    args,
    options,
    fetch,
  )
}
