/******************************************************************************
* This file was generated by ZenStack CLI.
******************************************************************************/

/* eslint-disable */
// @ts-nocheck

import type { Prisma, Personalization } from "@zenstackhq/runtime/models";
import type { UseMutationOptions, UseQueryOptions, UseInfiniteQueryOptions, InfiniteData } from '@tanstack/react-query';
import { getHooksContext } from '@zenstackhq/tanstack-query/runtime-v5/react';
import { useModelQuery, useInfiniteModelQuery, useModelMutation } from '@zenstackhq/tanstack-query/runtime-v5/react';
import type { PickEnumerable, CheckSelect, QueryError, ExtraQueryOptions, ExtraMutationOptions } from '@zenstackhq/tanstack-query/runtime-v5';
import type { PolicyCrudKind } from '@zenstackhq/runtime'
import metadata from './__model_meta';
type DefaultError = QueryError;
import { useSuspenseModelQuery, useSuspenseInfiniteModelQuery } from '@zenstackhq/tanstack-query/runtime-v5/react';
import type { UseSuspenseQueryOptions, UseSuspenseInfiniteQueryOptions } from '@tanstack/react-query';

export function useCreatePersonalization(options?: Omit<(UseMutationOptions<(Personalization | undefined), DefaultError, Prisma.PersonalizationCreateArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationCreateArgs, DefaultError, Personalization, true>('Personalization', 'POST', `${endpoint}/personalization/create`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationCreateArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationCreateArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationCreateArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useCreateManyPersonalization(options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.PersonalizationCreateManyArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationCreateManyArgs, DefaultError, Prisma.BatchPayload, false>('Personalization', 'POST', `${endpoint}/personalization/createMany`, metadata, options, fetch, false)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationCreateManyArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationCreateManyArgs>,
            options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationCreateManyArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as Prisma.BatchPayload;
        },
    };
    return mutation;
}

export function useFindManyPersonalization<TArgs extends Prisma.PersonalizationFindManyArgs, TQueryFnData = Array<Prisma.PersonalizationGetPayload<TArgs> & { $optimistic?: boolean }>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindManyArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findMany`, args, options, fetch);
}

export function useInfiniteFindManyPersonalization<TArgs extends Prisma.PersonalizationFindManyArgs, TQueryFnData = Array<Prisma.PersonalizationGetPayload<TArgs>>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindManyArgs>, options?: Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>) {
    options = options ?? { getNextPageParam: () => null };
    const { endpoint, fetch } = getHooksContext();
    return useInfiniteModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findMany`, args, options, fetch);
}

export function useSuspenseFindManyPersonalization<TArgs extends Prisma.PersonalizationFindManyArgs, TQueryFnData = Array<Prisma.PersonalizationGetPayload<TArgs> & { $optimistic?: boolean }>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindManyArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findMany`, args, options, fetch);
}

export function useSuspenseInfiniteFindManyPersonalization<TArgs extends Prisma.PersonalizationFindManyArgs, TQueryFnData = Array<Prisma.PersonalizationGetPayload<TArgs>>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindManyArgs>, options?: Omit<UseSuspenseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>) {
    options = options ?? { getNextPageParam: () => null };
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseInfiniteModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findMany`, args, options, fetch);
}

export function useFindUniquePersonalization<TArgs extends Prisma.PersonalizationFindUniqueArgs, TQueryFnData = Prisma.PersonalizationGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindUniqueArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findUnique`, args, options, fetch);
}

export function useSuspenseFindUniquePersonalization<TArgs extends Prisma.PersonalizationFindUniqueArgs, TQueryFnData = Prisma.PersonalizationGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindUniqueArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findUnique`, args, options, fetch);
}

export function useFindFirstPersonalization<TArgs extends Prisma.PersonalizationFindFirstArgs, TQueryFnData = Prisma.PersonalizationGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindFirstArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findFirst`, args, options, fetch);
}

export function useSuspenseFindFirstPersonalization<TArgs extends Prisma.PersonalizationFindFirstArgs, TQueryFnData = Prisma.PersonalizationGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationFindFirstArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/findFirst`, args, options, fetch);
}

export function useUpdatePersonalization(options?: Omit<(UseMutationOptions<(Personalization | undefined), DefaultError, Prisma.PersonalizationUpdateArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationUpdateArgs, DefaultError, Personalization, true>('Personalization', 'PUT', `${endpoint}/personalization/update`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationUpdateArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationUpdateArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationUpdateArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useUpdateManyPersonalization(options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.PersonalizationUpdateManyArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationUpdateManyArgs, DefaultError, Prisma.BatchPayload, false>('Personalization', 'PUT', `${endpoint}/personalization/updateMany`, metadata, options, fetch, false)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationUpdateManyArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationUpdateManyArgs>,
            options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationUpdateManyArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as Prisma.BatchPayload;
        },
    };
    return mutation;
}

export function useUpsertPersonalization(options?: Omit<(UseMutationOptions<(Personalization | undefined), DefaultError, Prisma.PersonalizationUpsertArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationUpsertArgs, DefaultError, Personalization, true>('Personalization', 'POST', `${endpoint}/personalization/upsert`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationUpsertArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationUpsertArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationUpsertArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useDeletePersonalization(options?: Omit<(UseMutationOptions<(Personalization | undefined), DefaultError, Prisma.PersonalizationDeleteArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationDeleteArgs, DefaultError, Personalization, true>('Personalization', 'DELETE', `${endpoint}/personalization/delete`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationDeleteArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationDeleteArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationDeleteArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, Personalization, Prisma.PersonalizationGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useDeleteManyPersonalization(options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.PersonalizationDeleteManyArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.PersonalizationDeleteManyArgs, DefaultError, Prisma.BatchPayload, false>('Personalization', 'DELETE', `${endpoint}/personalization/deleteMany`, metadata, options, fetch, false)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.PersonalizationDeleteManyArgs>(
            args: Prisma.SelectSubset<T, Prisma.PersonalizationDeleteManyArgs>,
            options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.SelectSubset<T, Prisma.PersonalizationDeleteManyArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as Prisma.BatchPayload;
        },
    };
    return mutation;
}

export function useAggregatePersonalization<TArgs extends Prisma.PersonalizationAggregateArgs, TQueryFnData = Prisma.GetPersonalizationAggregateType<TArgs>, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.PersonalizationAggregateArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/aggregate`, args, options, fetch);
}

export function useSuspenseAggregatePersonalization<TArgs extends Prisma.PersonalizationAggregateArgs, TQueryFnData = Prisma.GetPersonalizationAggregateType<TArgs>, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.PersonalizationAggregateArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/aggregate`, args, options, fetch);
}

export function useGroupByPersonalization<TArgs extends Prisma.PersonalizationGroupByArgs, HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<TArgs>>, Prisma.Extends<'take', Prisma.Keys<TArgs>>>, OrderByArg extends Prisma.True extends HasSelectOrTake ? { orderBy: Prisma.PersonalizationGroupByArgs['orderBy'] } : { orderBy?: Prisma.PersonalizationGroupByArgs['orderBy'] }, OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs['orderBy']>>>, ByFields extends Prisma.MaybeTupleToUnion<TArgs['by']>, ByValid extends Prisma.Has<ByFields, OrderFields>, HavingFields extends Prisma.GetHavingFields<TArgs['having']>, HavingValid extends Prisma.Has<ByFields, HavingFields>, ByEmpty extends TArgs['by'] extends never[] ? Prisma.True : Prisma.False, InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
        ? never
        : P extends string
        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
        : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`,
        ]
    }[HavingFields]
    : 'take' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields], TQueryFnData = {} extends InputErrors ?
    Array<PickEnumerable<Prisma.PersonalizationGroupByOutputType, TArgs['by']> &
        {
            [P in ((keyof TArgs) & (keyof Prisma.PersonalizationGroupByOutputType))]: P extends '_count'
            ? TArgs[P] extends boolean
            ? number
            : Prisma.GetScalarType<TArgs[P], Prisma.PersonalizationGroupByOutputType[P]>
            : Prisma.GetScalarType<TArgs[P], Prisma.PersonalizationGroupByOutputType[P]>
        }
    > : InputErrors, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.SubsetIntersection<TArgs, Prisma.PersonalizationGroupByArgs, OrderByArg> & InputErrors>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/groupBy`, args, options, fetch);
}

export function useSuspenseGroupByPersonalization<TArgs extends Prisma.PersonalizationGroupByArgs, HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<TArgs>>, Prisma.Extends<'take', Prisma.Keys<TArgs>>>, OrderByArg extends Prisma.True extends HasSelectOrTake ? { orderBy: Prisma.PersonalizationGroupByArgs['orderBy'] } : { orderBy?: Prisma.PersonalizationGroupByArgs['orderBy'] }, OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs['orderBy']>>>, ByFields extends Prisma.MaybeTupleToUnion<TArgs['by']>, ByValid extends Prisma.Has<ByFields, OrderFields>, HavingFields extends Prisma.GetHavingFields<TArgs['having']>, HavingValid extends Prisma.Has<ByFields, HavingFields>, ByEmpty extends TArgs['by'] extends never[] ? Prisma.True : Prisma.False, InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
        ? never
        : P extends string
        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
        : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`,
        ]
    }[HavingFields]
    : 'take' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields], TQueryFnData = {} extends InputErrors ?
    Array<PickEnumerable<Prisma.PersonalizationGroupByOutputType, TArgs['by']> &
        {
            [P in ((keyof TArgs) & (keyof Prisma.PersonalizationGroupByOutputType))]: P extends '_count'
            ? TArgs[P] extends boolean
            ? number
            : Prisma.GetScalarType<TArgs[P], Prisma.PersonalizationGroupByOutputType[P]>
            : Prisma.GetScalarType<TArgs[P], Prisma.PersonalizationGroupByOutputType[P]>
        }
    > : InputErrors, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.SubsetIntersection<TArgs, Prisma.PersonalizationGroupByArgs, OrderByArg> & InputErrors>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/groupBy`, args, options, fetch);
}

export function useCountPersonalization<TArgs extends Prisma.PersonalizationCountArgs, TQueryFnData = TArgs extends { select: any; } ? TArgs['select'] extends true ? number : Prisma.GetScalarType<TArgs['select'], Prisma.PersonalizationCountAggregateOutputType> : number, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationCountArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/count`, args, options, fetch);
}

export function useSuspenseCountPersonalization<TArgs extends Prisma.PersonalizationCountArgs, TQueryFnData = TArgs extends { select: any; } ? TArgs['select'] extends true ? number : Prisma.GetScalarType<TArgs['select'], Prisma.PersonalizationCountAggregateOutputType> : number, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.PersonalizationCountArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('Personalization', `${endpoint}/personalization/count`, args, options, fetch);
}

export function useCheckPersonalization<TError = DefaultError>(args: { operation: PolicyCrudKind; where?: { id?: string; lightPrimary?: string; lightPrimaryForeground?: string; lightPrimaryLight?: string; lightSecondary?: string; lightSecondaryForeground?: string; lightBackground?: string; lightBackgroundHover?: string; lightForeground?: string; lightCard?: string; lightCardForeground?: string; lightPopover?: string; lightPopoverForeground?: string; lightMuted?: string; lightMutedForeground?: string; lightAccent?: string; lightAccentForeground?: string; lightDestructive?: string; lightDestructiveForeground?: string; lightWarning?: string; lightWarningForeground?: string; lightBorder?: string; lightInput?: string; lightRing?: string; darkPrimary?: string; darkPrimaryForeground?: string; darkPrimaryLight?: string; darkSecondary?: string; darkSecondaryForeground?: string; darkBackground?: string; darkBackgroundHover?: string; darkForeground?: string; darkCard?: string; darkCardForeground?: string; darkPopover?: string; darkPopoverForeground?: string; darkMuted?: string; darkMutedForeground?: string; darkAccent?: string; darkAccentForeground?: string; darkDestructive?: string; darkDestructiveForeground?: string; darkWarning?: string; darkWarningForeground?: string; darkBorder?: string; darkInput?: string; darkRing?: string; lightSidebarBackground?: string; lightSidebarForeground?: string; lightSidebarPrimary?: string; lightSidebarPrimaryForeground?: string; lightSidebarAccent?: string; lightSidebarAccentForeground?: string; lightSidebarBorder?: string; lightSidebarRing?: string; darkSidebarBackground?: string; darkSidebarForeground?: string; darkSidebarPrimary?: string; darkSidebarPrimaryForeground?: string; darkSidebarAccent?: string; darkSidebarAccentForeground?: string; darkSidebarBorder?: string; darkSidebarRing?: string; chartColor1?: string; chartColor2?: string; chartColor3?: string; chartColor4?: string; chartColor5?: string }; }, options?: (Omit<UseQueryOptions<boolean, TError, boolean>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<boolean, boolean, TError>('Personalization', `${endpoint}/personalization/check`, args, options, fetch);
}
